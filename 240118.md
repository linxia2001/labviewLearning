#### 全局变量

在labview中应当尽量避免使用全局变量和局部变量。全局变量看似方便，但带来的问题也很多。最主要是它破坏了数据流顺序的逻辑关系，导致程序可读性和可维护性下降。
偶尔也会存在不得不使用全局变量或者使用它利大于弊的情况，例如，在需要实现子VI间参数传引用的机制时；在不破坏程序可读性的前提下，需要避免一些不必要的数据连线，从而美化程序框图时。

**全局变量VI有其局限性：**
首先是前面板已经提到过的，全局变量破坏了数据流顺序的逻辑关系，而且不利于代码的可读性。使用全局变量，难以判断数据是否在其他地方被改动过，而且无法控制其改动。换言之，代码上的全局变量，不能直观地反映出它的数据来源。
其次，VI每次读取全局变量数据，Labview都要为读到的数据复制一个新的副本，这毫无疑问影响到了VI的效率。
第三，全局变量的不合理使用可能导致竞争状态。竞争状态是指在多个线程中，由于同时访问同一资源所引发的程序结果的不确定情况。

#### 使用事件结构的经验

- 检测界面的按钮是否被按下，应当使用“值改变”事件。“鼠标按下”和“鼠标释放”有时会起到同样的效果，但有时（比如鼠标在按下后又移动）往往就不能真实反映按钮的状态了。此外，用作按钮的布尔控件应当选择“释放时触发”机械动作。
- 应尽量避免在一个分支内处理多个事件。在程序较为复杂时，它会降低程序可读性以及可维护性。
- 在一个VI内，最多只能有一个事件结构。虽然Labview并不禁止在一个VI内使用多个事件结构，但是多个事件结构极易造成程序逻辑错误，而且也没有任何必要。在一个VI内，完全可以把所有的事件都放到了一个事件结构中区处理。
- 通常只有当用户在界面上改变了一个控件的值，Labview才会产生值改变事件。在程序中，直接赋值给控件的接线端或局部变量是不会产生值改变事件的。如果希望在程序中改变控件值的同时也让它发出值改变事件，可以把值赋给控件的“值（信号）”属性。

#### 调用外部程序

动态链接库（DLL）是一种“程序库”。库内存放的是可供应用程序使用的函数、变量等。

“动态”是与“静态”相对应而来的。这里的动态和静态是指链接库中代码与使用它们的应用程序之间的链接关系。如果采用静态链接库，在生成应用程序时，库中的函数等都会被直接放入最终生成的可执行文件中；而使用动态链接库时，库中的函数等不会被放到可执行文件中去，而是仍然保留在DLL文件内。当程序被运行时，再链接到动态链接库中的函数和变量等内容。

“在UI线程中运行”是指在UI线程（即界面线程）中运行被调用的函数。Labview程序不论多么复杂，都只有一个界面线程。这个线程用于处理所有与界面相关的工作，如显示一个数据、产生一个用户事件等。由于程序中只有一个界面线程，如果把多个被调用的函数都设置为在界面线程中运行，就可以确保这些函数在同一线程内运行。

labview除了界面线程之外，还有多个其他执行线程，用于执行程序框图中的代码。如果选择“在任一线程中运行”，就不能确定Labview会在哪个线程内运行这个DLL函数。

可以按照以下判断方法选择CLN节点中的线程设置：如果被调用的动态链接库是多线程安全的，则选择“在任一线程中运行”；否则，动态链接库就不是多线程安全的，就得选择“在UI线程汇总运行”。选择在任一线程中运行一个DLL函数，程序的运行效率比较高。因为Labview可以把DLL函数放在与其前后程序代码相同的线程内执行，从而就省去了线程切换的开销。并且，该设置允许labview在不同的线程内同时调用同一个DLL函数，并行执行的速度通常比串行高一些。但是，如果DLL不是多线程安全的，也就意味着在不同线程内同时调用DLL中的函数可能出现错误，那么必须禁止这种情况的出现。这时，只能把CLN节点设置为“在UI线程中运行”，以确保所有DLL函数都只在一个线程内运行。

判断一个动态链接库是否为线程安全的，也需要费一番心思。如果这个动态链接库文件中没有明确说明它是多线程安全的，那么为稳妥起见，应该把它当成非多线程安全的。

“调用规范”用于指明被调用功函数的参数压栈规范。CLN节点支持两种规范：stdcall和C call。它们之间的区别在于，stdcall由被调用者负责清理堆栈，C call由调用者清理堆栈。如果调用规范设置错误，则可能引起Labview崩溃，所以一定要小心。反过来说，如果labview调用DLL函数时出现异常，首先就应该考虑这个设置是否正确。

Windows API一般使用stdcall，标准C的库函数大多使用C call。如果函数声明中有类似“_stdcall”这样的关键字，则它就是stdcall的。

