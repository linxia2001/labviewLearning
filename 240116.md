###### 应用于多线程间的共享数据

要在多个线程中同时使用同一个数据，就需要使用局部变量来解决。

###### 强制转换的用途

只有那些内部表达方式相同的数据类型之间进行强制类型转换，新类型的数据才可能会有意义。只有那些在内存中原本就是以平化方式存储的数据，才可以使用强制类型转换函数。

比如把一个数值数组平化至字符串后，字符串内包含的信息有数组长度以及数组中的数据；而强制类型转换为字符串，字符串内只有数组数据的信息。

**平铺式顺序结构与层叠式顺序结构的功能完全相同，区别仅仅在于：** 平铺式顺序结构可以把所有的框架按照从左到右的顺序展开在框图上，而层叠式顺序结构的每个框架是重叠的，每一时刻都只有一个框架可以直接在VI的框图上显示出来。

反馈节点和移位寄存器的功能与本质是完全相同的。反馈节点的优点在于它不需要从循环的边框上连接数据线。因此，可以把程序写的更简洁美观。尤其是熟悉反馈概念的控制或电子专业的工程师们，可以直观地理解这一节点的用途。由于反馈节点实际依赖于循环结构，而它们之间又没有数据线连接，使用反馈节点时，一不小心就可能把逻辑关系弄错。另外，反馈节点也会导致某些连线上数据的逆向流动。如果逆向数据线过长，不利于阅读程序，就不如使用移位寄存器了。

应该尽量避免在同一VI上使用多个事件结构。实际上每个VI中只需一个事件结构就可以处理所有的事件了。

**定时结构：** 
“等待”、“等待下一个整数倍毫秒”或“时间延迟”函数，这三个函数的用法是完全相同的。
它们可以分辨的最小等待或延时时间也是相同的：2ms，它们唯一的差别在于精度。“等待”与“时间延迟”的精度是相同的，它们每执行一次的误差可达数个毫秒。“等待下一个整数倍毫秒“的精度要高一些。
“等待”函数比较容易理解：给定一个输入参数n毫秒，每次程序执行到它的时候，它就会停下来等待n毫秒，再继续运行后续程序。
“等待下一个整数倍毫秒”函数稍微复杂一些：给定一个输入参数n毫秒，每次程序执行到它的时候都会暂停在这里，函数每隔n毫秒醒来一次，醒来后再继续运行后续程序。
在Windows这样的非实时操作系统中，定时函数的精度是非常低的，每运行一次出现几毫秒误差是正常的现象。使用“等待”函数，每次循环运行到它时才开始计时，因此单次的误差会被累计。假如每次误差四五毫秒，迭代五次误差就可能达到十几毫秒了。
而“等待下一次整数倍毫秒”函数，并非是在每次调用的时候计算延时的。假设函数从0时间开始计时，那么程序一开始运行，它就知道自己每一次醒来的时间分别应当是：100ms、200ms、300ms…..。假如误差是±4ms，那么它实际每次醒来的时间就是(100±4)ms、（200±4)ms、(300±4)ms……，这个误差不会被累计。

